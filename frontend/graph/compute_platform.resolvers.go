package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"

	"github.com/odigos-io/odigos/api/k8sconsts"
	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/kube"
	"github.com/odigos-io/odigos/frontend/services"
	"github.com/odigos-io/odigos/k8sutils/pkg/env"
	"github.com/odigos-io/odigos/k8sutils/pkg/workload"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// APITokens is the resolver for the apiTokens field.
func (r *computePlatformResolver) APITokens(ctx context.Context, obj *model.ComputePlatform) ([]*model.APIToken, error) {
	ns := env.GetCurrentNamespace()

	// The result should always be 0 or 1:
	// If it's 0, it means this is the OSS version.
	// If it's 1, it means this is the Enterprise version.

	secret, err := kube.DefaultClient.CoreV1().Secrets(ns).Get(ctx, k8sconsts.OdigosProSecretName, metav1.GetOptions{})
	if err != nil {
		if apierrors.IsNotFound(err) {
			return make([]*model.APIToken, 0), nil
		}
		return nil, err
	}

	token := string(secret.Data[k8sconsts.OdigosOnpremTokenSecretKey])

	// Extract the payload from the JWT
	tokenPayload, err := extractJWTPayload(token)
	if err != nil {
		// We don't want to return an error here, because the user may have provided a bad token.
		// Throwing this will prevent the entire CP from being fetched, and prevent the user from being able to update the token...
		// return nil, fmt.Errorf("failed to extract JWT payload: %w", err)

		return []*model.APIToken{
			{
				Token:     token,
				Name:      "ERROR",
				IssuedAt:  0,
				ExpiresAt: 0,
			},
		}, nil
	}

	// Extract values from the token payload
	aud, _ := tokenPayload["aud"].(string)
	iat, _ := tokenPayload["iat"].(float64)
	exp, _ := tokenPayload["exp"].(float64)

	// We need to return an array (even if it's just 1 token), because in the future we will have to support multiple platforms.
	return []*model.APIToken{
		{
			Token:     token,
			Name:      aud,
			IssuedAt:  int(iat) * 1000, // Convert to milliseconds
			ExpiresAt: int(exp) * 1000, // Convert to milliseconds
		},
	}, nil
}

// K8sActualNamespaces is the resolver for the k8sActualNamespaces field.
func (r *computePlatformResolver) K8sActualNamespaces(ctx context.Context, obj *model.ComputePlatform) ([]*model.K8sActualNamespace, error) {
	return services.GetK8SNamespaces(ctx, nil)
}

// K8sActualNamespace is the resolver for the k8sActualNamespace field.
func (r *computePlatformResolver) K8sActualNamespace(ctx context.Context, obj *model.ComputePlatform, name string) (*model.K8sActualNamespace, error) {
	namespaces, err := services.GetK8SNamespaces(ctx, &name)
	if err != nil {
		return nil, err
	}
	if len(namespaces) == 0 {
		return nil, fmt.Errorf("no namespaces found with name %s", name)
	}
	if len(namespaces) > 1 {
		return nil, fmt.Errorf("multiple namespaces found with name %s", name)
	}
	return namespaces[0], nil
}

// Sources is the resolver for the sources field.
func (r *computePlatformResolver) Sources(ctx context.Context, obj *model.ComputePlatform) ([]*model.K8sActualSource, error) {
	icList, err := kube.DefaultClient.OdigosClient.InstrumentationConfigs("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	sources := make([]*model.K8sActualSource, 0)
	for _, ic := range icList.Items {
		dataStreamNames := services.ExtractDataStreamsFromInstrumentationConfig(&ic)
		source, err := instrumentationConfigToActualSource(ctx, ic, dataStreamNames)
		if err != nil {
			return nil, err
		}
		sources = append(sources, source)
	}

	return sources, nil
}

// Source is the resolver for the source field.
func (r *computePlatformResolver) Source(ctx context.Context, obj *model.ComputePlatform, sourceID model.K8sSourceID) (*model.K8sActualSource, error) {
	ns := sourceID.Namespace
	kind := sourceID.Kind
	name := sourceID.Name

	ic, err := kube.DefaultClient.OdigosClient.InstrumentationConfigs(ns).Get(ctx, workload.CalculateWorkloadRuntimeObjectName(name, string(kind)), metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get InstrumentationConfig: %w", err)
	}
	if ic == nil {
		return nil, fmt.Errorf("InstrumentationConfig not found for %s/%s in namespace %s", kind, name, ns)
	}

	dataStreamNames := services.ExtractDataStreamsFromInstrumentationConfig(ic)
	payload, err := instrumentationConfigToActualSource(ctx, *ic, dataStreamNames)
	if err != nil {
		return nil, fmt.Errorf("failed to get Source: %w", err)
	}

	otherConditions, err := services.GetOtherConditionsForSources(ctx, ns, name, string(kind))
	if err != nil {
		return nil, err
	}
	for _, item := range otherConditions {
		payload.Conditions = append(payload.Conditions, item.Conditions...)
	}

	services.SortConditions(payload.Conditions)

	return payload, nil
}

// Destinations is the resolver for the destinations field.
func (r *computePlatformResolver) Destinations(ctx context.Context, obj *model.ComputePlatform) ([]*model.Destination, error) {
	ns := env.GetCurrentNamespace()

	dests, err := kube.DefaultClient.OdigosClient.Destinations(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	var destinations []*model.Destination
	for _, dest := range dests.Items {
		secretFields := make(map[string]string)

		if !services.IsReadonlyMode(ctx) {
			secretFields, err = services.GetDestinationSecretFields(ctx, ns, &dest)
			if err != nil {
				return nil, err
			}
		}

		// Convert the k8s destination format to the expected endpoint format
		endpointDest := services.K8sDestinationToEndpointFormat(dest, secretFields)
		destinations = append(destinations, &endpointDest)
	}

	return destinations, nil
}

// Actions is the resolver for the actions field.
func (r *computePlatformResolver) Actions(ctx context.Context, obj *model.ComputePlatform) ([]*model.Action, error) {
	return services.GetActions(ctx)
}

// InstrumentationRules is the resolver for the instrumentationRules field.
func (r *computePlatformResolver) InstrumentationRules(ctx context.Context, obj *model.ComputePlatform) ([]*model.InstrumentationRule, error) {
	return services.GetInstrumentationRules(ctx)
}

// DataStreams is the resolver for the dataStreams field.
func (r *computePlatformResolver) DataStreams(ctx context.Context, obj *model.ComputePlatform) ([]*model.DataStream, error) {
	ns := env.GetCurrentNamespace()

	dataStreams := make([]*model.DataStream, 0)
	seen := make(map[string]bool) // prevent duplicates

	dataStreams = append(dataStreams, &model.DataStream{Name: "default"})
	seen["default"] = true

	instrumentationConfigs, err := kube.DefaultClient.OdigosClient.InstrumentationConfigs("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, ic := range instrumentationConfigs.Items {
		for _, name := range services.ExtractDataStreamsFromInstrumentationConfig(&ic) {
			if !seen[*name] {
				seen[*name] = true
				dataStreams = append(dataStreams, &model.DataStream{
					Name: *name,
				})
			}
		}
	}

	destinations, err := kube.DefaultClient.OdigosClient.Destinations(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, dest := range destinations.Items {
		for _, name := range services.ExtractDataStreamsFromDestination(dest) {
			if !seen[*name] {
				seen[*name] = true
				dataStreams = append(dataStreams, &model.DataStream{
					Name: *name,
				})
			}
		}
	}

	return dataStreams, nil
}

// ComputePlatform is the resolver for the computePlatform field.
func (r *queryResolver) ComputePlatform(ctx context.Context) (*model.ComputePlatform, error) {
	return &model.ComputePlatform{
		ComputePlatformType: model.ComputePlatformTypeK8s,
	}, nil
}

// ComputePlatform returns ComputePlatformResolver implementation.
func (r *Resolver) ComputePlatform() ComputePlatformResolver { return &computePlatformResolver{r} }

type computePlatformResolver struct{ *Resolver }
