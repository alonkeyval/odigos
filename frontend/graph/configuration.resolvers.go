package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"

	"github.com/odigos-io/odigos/api/k8sconsts"
	"github.com/odigos-io/odigos/common"
	"github.com/odigos-io/odigos/common/consts"
	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/kube"
	"github.com/odigos-io/odigos/frontend/services"
	"github.com/odigos-io/odigos/k8sutils/pkg/env"
	"github.com/odigos-io/odigos/k8sutils/pkg/pro"
	"github.com/odigos-io/odigos/k8sutils/pkg/restart"
	yaml "gopkg.in/yaml.v2"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// UpdateAPIToken is the resolver for the updateApiToken field.
func (r *mutationResolver) UpdateAPIToken(ctx context.Context, token string) (bool, error) {
	ns := env.GetCurrentNamespace()
	err := pro.UpdateOdigosToken(ctx, kube.DefaultClient, ns, token)
	return err == nil, nil
}

// UpdateOdigosConfig is the resolver for the updateOdigosConfig field.
func (r *mutationResolver) UpdateOdigosConfig(ctx context.Context, odigosConfig model.OdigosConfigurationInput) (bool, error) {
	ns := env.GetCurrentNamespace()
	cm, err := kube.DefaultClient.CoreV1().ConfigMaps(ns).Get(ctx, consts.OdigosConfigurationName, metav1.GetOptions{})
	if err != nil {
		return false, fmt.Errorf("failed to get odigos configuration: %v", err)
	}

	var prevCfg common.OdigosConfiguration
	if cm.Data != nil && cm.Data[consts.OdigosConfigurationFileName] != "" {
		if err := yaml.Unmarshal([]byte(cm.Data[consts.OdigosConfigurationFileName]), &prevCfg); err != nil {
			prevCfg = common.OdigosConfiguration{}
		}
	}

	cfg, err := convertOdigosConfigToK8s(&odigosConfig)
	if err != nil {
		return false, fmt.Errorf("failed to convert odigos configuration: %v", err)
	}

	if cfg.Oidc != nil && cfg.Oidc.ClientSecret != "" {
		// ensure the oidc secret exists and is updated
		err = services.EnsureOidcSecret(ctx, cfg.Oidc.ClientSecret)
		if err != nil {
			return false, fmt.Errorf("failed to ensure oidc secret: %v", err)
		}
		// update the odigos configmap with the secret ref
		cfg.Oidc.ClientSecret = fmt.Sprintf("secretRef:%s", consts.OidcSecretName)
	}

	yamlBytes, err := yaml.Marshal(cfg)
	if err != nil {
		return false, fmt.Errorf("failed to marshal odigos configuration: %v", err)
	}

	if cm.Data == nil {
		cm.Data = make(map[string]string)
	}
	cm.Data[consts.OdigosConfigurationFileName] = string(yamlBytes)

	_, err = kube.DefaultClient.CoreV1().ConfigMaps(ns).Update(ctx, cm, metav1.UpdateOptions{})
	if err != nil {
		return false, fmt.Errorf("failed to update odigos configuration: %v", err)
	}

	// restart central-proxy when central-backend-url or cluster-name changed and both are set in on-prem tier
	// determine tier
	depCM, err := kube.DefaultClient.CoreV1().ConfigMaps(ns).Get(ctx, k8sconsts.OdigosDeploymentConfigMapName, metav1.GetOptions{})
	if err == nil {
		tier := depCM.Data[k8sconsts.OdigosDeploymentConfigMapTierKey]
		if tier == string(common.OnPremOdigosTier) {
			changed := prevCfg.CentralBackendURL != cfg.CentralBackendURL || prevCfg.ClusterName != cfg.ClusterName
			bothSet := cfg.CentralBackendURL != "" && cfg.ClusterName != ""
			if changed && bothSet {
				_ = restart.RestartDeployment(ctx, kube.DefaultClient.Interface, env.GetCurrentNamespace(), k8sconsts.CentralProxyDeploymentName)
			}
		}
	}

	return true, nil
}

// UninstrumentCluster is the resolver for the uninstrumentCluster field.
func (r *mutationResolver) UninstrumentCluster(ctx context.Context) (bool, error) {
	err := services.UninstrumentCluster(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to uninstrument cluster: %v", err)
	}
	return true, nil
}

// PauseOdigos is the resolver for the pauseOdigos field.
func (r *mutationResolver) PauseOdigos(ctx context.Context) (bool, error) {
	if err := services.PauseOdigos(ctx); err != nil {
		return false, fmt.Errorf("failed to pause odigos: %v", err)
	}
	return true, nil
}

// DeleteCentralProxy is the resolver for the deleteCentralProxy field.
func (r *mutationResolver) DeleteCentralProxy(ctx context.Context) (bool, error) {
	return services.DeleteCentralProxy(ctx)
}

// OdigosConfig is the resolver for the odigosConfig field.
func (r *queryResolver) OdigosConfig(ctx context.Context) (*model.OdigosConfiguration, error) {
	cm, err := kube.DefaultClient.CoreV1().ConfigMaps(env.GetCurrentNamespace()).Get(ctx, consts.OdigosEffectiveConfigName, metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get odigos configuration: %v", err)
	}

	cfg := common.OdigosConfiguration{}
	err = yaml.Unmarshal([]byte(cm.Data[consts.OdigosConfigurationFileName]), &cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal odigos configuration: %v", err)
	}

	odigosConfig, err := convertOdigosConfigToGql(&cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to convert odigos configuration: %v", err)
	}
	if odigosConfig.Oidc != nil {
		oidcSecret, err := services.GetOidcSecret(ctx)
		if err != nil && !apierrors.IsNotFound(err) {
			return nil, fmt.Errorf("failed to get oidc secret: %v", err)
		}
		odigosConfig.Oidc.ClientSecret = &oidcSecret
	}

	return odigosConfig, nil
}

// Config is the resolver for the config field.
func (r *queryResolver) Config(ctx context.Context) (*model.GetConfigResponse, error) {
	config := services.GetConfig(ctx)

	return &config, nil
}
