package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"

	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/kube"
	"github.com/odigos-io/odigos/frontend/services"
	"github.com/odigos-io/odigos/k8sutils/pkg/env"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// UpdateDataStream is the resolver for the updateDataStream field.
func (r *mutationResolver) UpdateDataStream(ctx context.Context, id string, dataStream model.DataStreamInput) (*model.DataStream, error) {
	idNew := dataStream.Name
	if id == idNew {
		return &model.DataStream{Name: idNew}, nil
	}

	ns := env.GetCurrentNamespace()
	kubeClient := kube.DefaultClient.OdigosClient

	destinations, err := kubeClient.Destinations(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	err = services.UpdateDestinationsCurrentStreamName(ctx, destinations, id, idNew)
	if err != nil {
		return nil, fmt.Errorf("failed to update destinations: %v", err)
	}

	sources, err := kubeClient.Sources("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	err = services.UpdateSourcesCurrentStreamName(ctx, sources, id, idNew)
	if err != nil {
		return nil, fmt.Errorf("failed to update sources: %v", err)
	}

	return &model.DataStream{Name: idNew}, nil
}

// DeleteDataStream is the resolver for the deleteDataStream field.
func (r *mutationResolver) DeleteDataStream(ctx context.Context, id string) (bool, error) {
	kubeClient := kube.DefaultClient.OdigosClient

	destinations, err := kubeClient.Destinations(env.GetCurrentNamespace()).List(ctx, metav1.ListOptions{})
	if err != nil {
		return false, err
	}
	err = services.DeleteDestinationsOrRemoveStreamName(ctx, destinations, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete destinations or remove stream name: %v", err)
	}

	sources, err := kubeClient.Sources("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return false, err
	}
	err = services.DeleteSourcesOrRemoveStreamName(ctx, sources, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete sources or remove stream name: %v", err)
	}

	return true, nil
}
