package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"

	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/services"
	"github.com/odigos-io/odigos/frontend/services/describe/odigos_describe"
	"github.com/odigos-io/odigos/frontend/services/describe/source_describe"
)

// DescribeOdigos is the resolver for the describeOdigos field.
func (r *queryResolver) DescribeOdigos(ctx context.Context) (*model.OdigosAnalyze, error) {
	return odigos_describe.GetOdigosDescription(ctx)
}

// DescribeSource is the resolver for the describeSource field.
func (r *queryResolver) DescribeSource(ctx context.Context, namespace string, kind string, name string) (*model.SourceAnalyze, error) {
	return source_describe.GetSourceDescription(ctx, namespace, kind, name)
}

// SourceConditions is the resolver for the sourceConditions field.
func (r *queryResolver) SourceConditions(ctx context.Context) ([]*model.SourceConditions, error) {
	return services.GetOtherConditionsForSources(ctx, "", "", "")
}

// InstrumentationInstanceComponents is the resolver for the instrumentationInstanceComponents field.
func (r *queryResolver) InstrumentationInstanceComponents(ctx context.Context, namespace string, kind string, name string) ([]*model.InstrumentationInstanceComponent, error) {
	instances, err := services.GetInstrumentationInstances(ctx, namespace, name, kind)
	if err != nil {
		return nil, err
	}

	// Return empty components if no instrumentation instances found
	if len(instances) == 0 {
		return []*model.InstrumentationInstanceComponent{}, nil
	}

	components := make([]*model.InstrumentationInstanceComponent, 0)
	seenNames := make(map[string]bool)

	for _, instance := range instances {
		for _, component := range instance.Status.Components {
			nonIdentifyingAttributes := make([]*model.NonIdentifyingAttribute, 0)

			for _, attribute := range component.NonIdentifyingAttributes {
				nonIdentifyingAttributes = append(nonIdentifyingAttributes, &model.NonIdentifyingAttribute{
					Key:   attribute.Key,
					Value: attribute.Value,
				})
			}

			if _, ok := seenNames[component.Name]; !ok {
				seenNames[component.Name] = true
				components = append(components, &model.InstrumentationInstanceComponent{
					Name:                     component.Name,
					NonIdentifyingAttributes: nonIdentifyingAttributes,
				})
			}
		}
	}

	return components, nil
}
