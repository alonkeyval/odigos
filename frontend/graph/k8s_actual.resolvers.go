package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/odigos-io/odigos/api/k8sconsts"
	"github.com/odigos-io/odigos/api/odigos/v1alpha1"
	"github.com/odigos-io/odigos/common"
	"github.com/odigos-io/odigos/frontend/graph/loaders"
	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/graph/status"
	"github.com/odigos-io/odigos/frontend/kube"
	"github.com/odigos-io/odigos/frontend/services"
	frontendcommon "github.com/odigos-io/odigos/frontend/services/common"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// Sources is the resolver for the sources field.
func (r *k8sActualNamespaceResolver) Sources(ctx context.Context, obj *model.K8sActualNamespace) ([]*model.K8sActualSource, error) {
	ns := obj.Name

	workloads, err := services.GetWorkloadsInNamespace(ctx, ns)
	if err != nil {
		return nil, err
	}

	sourceList, err := kube.DefaultClient.OdigosClient.Sources(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	var namespaceSource *v1alpha1.Source
	sourceObjects := make(map[string]*v1alpha1.Source)

	for _, source := range sourceList.Items {
		if model.K8sResourceKind(source.Spec.Workload.Kind) == services.WorkloadKindNamespace {
			namespaceSource = &source
		} else {
			key := fmt.Sprintf("%s/%s/%s", source.Spec.Workload.Namespace, source.Spec.Workload.Name, source.Spec.Workload.Kind)
			sourceObjects[key] = &source
		}
	}

	// Convert workloads to []*model.K8sActualSource
	sources := make([]*model.K8sActualSource, len(workloads))
	for i, workload := range workloads {
		key := fmt.Sprintf("%s/%s/%s", workload.Namespace, workload.Name, workload.Kind)
		workloadSource := sourceObjects[key]

		namespaceInstrumented := namespaceSource != nil && !namespaceSource.Spec.DisableInstrumentation
		sourceInstrumented := workloadSource != nil && !workloadSource.Spec.DisableInstrumentation
		isInstrumented := (namespaceInstrumented && (sourceInstrumented || workloadSource == nil)) || (!namespaceInstrumented && sourceInstrumented)

		sources[i] = &workload
		sources[i].Selected = &isInstrumented
		sources[i].DataStreamNames = make([]*string, 0)

		if workloadSource != nil {
			sources[i].DataStreamNames = services.ExtractDataStreamsFromSource(workloadSource, namespaceSource)
		}
	}

	return sources, nil
}

// WorkloadOdigosHealthStatus is the resolver for the workloadOdigosHealthStatus field.
func (r *k8sActualSourceResolver) WorkloadOdigosHealthStatus(ctx context.Context, obj *model.K8sActualSource) (*model.DesiredConditionStatus, error) {
	// Create a workload ID from the K8sActualSource
	workloadID := &model.K8sWorkloadID{
		Namespace: obj.Namespace,
		Kind:      obj.Kind,
		Name:      obj.Name,
	}

	// Set up loaders with a filter for this specific workload
	l := loaders.For(ctx)
	filter := &model.WorkloadFilter{
		Namespace: &obj.Namespace,
		Kind:      &obj.Kind,
		Name:      &obj.Name,
	}
	err := l.SetFilters(ctx, filter)
	if err != nil {
		return nil, err
	}

	// Get the instrumentation config
	ic, err := l.GetInstrumentationConfig(ctx, *workloadID)
	if err != nil {
		return nil, err
	}

	// Get the pods
	pods, err := l.GetWorkloadPods(ctx, *workloadID)
	if err != nil {
		return nil, err
	}

	// Calculate the health status using the same logic as K8sWorkload resolver
	conditions := []*model.DesiredConditionStatus{}
	if ic != nil {
		conditions = append(conditions, status.CalculateRuntimeInspectionStatus(ic))
		conditions = append(conditions, status.CalculateAgentInjectionEnabledStatus(ic))
		conditions = append(conditions, status.CalculateRolloutStatus(ic))
	} else {
		reasonStr := string(status.WorkloadOdigosHealthStatusReasonDisabled)
		conditions = append(conditions, &model.DesiredConditionStatus{
			Name:       status.WorkloadOdigosHealthStatus,
			Status:     model.DesiredStateProgressDisabled,
			ReasonEnum: &reasonStr,
			Message:    "workload is not marked for instrumentation",
		})
	}

	// always report if agent is injected or not, even if the workload is not marked for instrumentation.
	// this is to detect if uninstrumented pods have agent injected when it should not.
	conditions = append(conditions, status.CalculateAgentInjectedStatus(ic, pods))
	aggregateContainerProcessesHealth, err := aggregateProcessesHealthForWorkload(ctx, workloadID)
	if err != nil {
		return nil, err
	}
	conditions = append(conditions, aggregateContainerProcessesHealth)

	mostSevereCondition := aggregateConditionsBySeverity(conditions)
	if mostSevereCondition == nil {
		mostSevereCondition = &model.DesiredConditionStatus{
			Name:       status.WorkloadOdigosHealthStatus,
			Status:     model.DesiredStateProgressUnknown,
			ReasonEnum: nil,
			Message:    "",
		}
	}

	// exception, if all is well, we return a special condition to denote it
	if mostSevereCondition.Status == model.DesiredStateProgressSuccess {

		workloadMetrics, ok := r.MetricsConsumer.GetSingleSourceMetrics(frontendcommon.SourceID{
			Namespace: obj.Namespace,
			Kind:      k8sconsts.WorkloadKind(obj.Kind),
			Name:      obj.Name,
		})
		var totalDataSent *int
		if ok {
			tds := int(workloadMetrics.TotalDataSent())
			totalDataSent = &tds
		}

		// consider the telemetry metrics status if relevant.
		telemetryMetrics := status.CalculateExpectingTelemetryStatus(ic, pods, totalDataSent)
		expectingTelemetry := telemetryMetrics != nil && telemetryMetrics.IsExpectingTelemetry != nil && *telemetryMetrics.IsExpectingTelemetry

		var reasonStr, message string
		if expectingTelemetry {
			if telemetryMetrics.TelemetryObservedStatus.Status == model.DesiredStateProgressSuccess {
				reasonStr = string(status.WorkloadOdigosHealthStatusReasonSuccessAndEmittingTelemetry)
				message = "source is instrumented, healthy and telemetry has been observed"
			} else {
				reasonStr = string(status.WorkloadOdigosHealthStatusReasonSuccess)
				message = "source is instrumented and healthy, no telemetry recorded yet"
			}
		} else {
			reasonStr = string(status.WorkloadOdigosHealthStatusReasonSuccess)
			message = "source is healthy, no telemetry is expected"
		}
		return &model.DesiredConditionStatus{
			Name:       status.WorkloadOdigosHealthStatus,
			Status:     model.DesiredStateProgressSuccess,
			ReasonEnum: &reasonStr,
			Message:    message,
		}, nil
	}

	return mostSevereCondition, nil
}

// PersistK8sNamespaces is the resolver for the persistK8sNamespaces field.
func (r *mutationResolver) PersistK8sNamespaces(ctx context.Context, namespaces []*model.PersistNamespaceItemInput) (bool, error) {
	persistObjects := []*model.PersistNamespaceSourceInput{}
	for _, namespace := range namespaces {
		persistObjects = append(persistObjects, &model.PersistNamespaceSourceInput{
			Namespace:         namespace.Namespace,
			Name:              namespace.Namespace,
			Kind:              model.K8sResourceKind(services.WorkloadKindNamespace),
			Selected:          namespace.Selected,
			CurrentStreamName: namespace.CurrentStreamName,
		})
	}

	err := services.SyncWorkloadsInNamespace(ctx, persistObjects)
	if err != nil {
		return false, fmt.Errorf("failed to sync workloads: %v", err)
	}

	return true, nil
}

// PersistK8sSources is the resolver for the persistK8sSources field.
func (r *mutationResolver) PersistK8sSources(ctx context.Context, sources []*model.PersistNamespaceSourceInput) (bool, error) {
	err := services.SyncWorkloadsInNamespace(ctx, sources)
	if err != nil {
		return false, fmt.Errorf("failed to sync workloads: %v", err)
	}

	return true, nil
}

// UpdateK8sActualSource is the resolver for the updateK8sActualSource field.
func (r *mutationResolver) UpdateK8sActualSource(ctx context.Context, sourceID model.K8sSourceID, patchSourceRequest model.PatchSourceRequestInput) (bool, error) {
	nsName := sourceID.Namespace
	workloadName := sourceID.Name
	workloadKind := sourceID.Kind
	source, err := services.GetSourceCRD(ctx, nsName, workloadName, workloadKind)
	if err != nil {
		if !apierrors.IsNotFound(err) {
			// unexpected error occurred while trying to get the source
			return false, err
		}
		source, err = services.EnsureSourceCRD(ctx, nsName, workloadName, workloadKind, patchSourceRequest.CurrentStreamName)
		if err != nil {
			// unexpected error occurred while trying to create the source
			return false, err
		}
	}

	otelServiceName := patchSourceRequest.OtelServiceName
	if otelServiceName != nil {
		_, err = services.UpdateSourceCRDSpec(ctx, nsName, source.Name, "otelServiceName", fmt.Sprintf("\"%s\"", *otelServiceName))
		if err != nil {
			// unexpected error occurred while trying to update the source
			return false, err
		}
	}

	cont := patchSourceRequest.ContainerName
	lang := patchSourceRequest.Language
	vers := patchSourceRequest.Version
	if cont != nil {
		containerOverrides := make([]v1alpha1.ContainerOverride, 0)
		// get previous overrides (except the one we are updating)
		if source.Spec.ContainerOverrides != nil {
			for _, override := range source.Spec.ContainerOverrides {
				if override.ContainerName != *cont {
					containerOverrides = append(containerOverrides, override)
				}
			}
		}
		// add the new override
		var overrideRuntimeInfo *v1alpha1.RuntimeDetailsByContainer
		if lang == nil || *lang == "" {
			overrideRuntimeInfo = nil
		} else {
			runtimeVersion := ""
			if vers != nil && *vers != "" {
				if common.GetVersion(*vers) == nil {
					return false, fmt.Errorf("invalid runtime version: %s", *vers)
				}
				runtimeVersion = *vers
			}
			overrideRuntimeInfo = &v1alpha1.RuntimeDetailsByContainer{
				ContainerName:  *cont,
				Language:       common.ProgrammingLanguage(*lang),
				RuntimeVersion: runtimeVersion,
			}
		}
		containerOverrides = append(containerOverrides, v1alpha1.ContainerOverride{
			ContainerName: *cont,
			RuntimeInfo:   overrideRuntimeInfo,
		})
		// patch the source with the new container overrides
		patchBytes, err := json.Marshal([]map[string]interface{}{
			{
				"op":    "replace",
				"path":  "/spec/containerOverrides",
				"value": containerOverrides,
			},
		})
		if err != nil {
			return false, err
		}
		_, err = kube.DefaultClient.OdigosClient.Sources(nsName).Patch(ctx, source.Name, types.JSONPatchType, []byte(patchBytes), metav1.PatchOptions{})
		if err != nil {
			return false, err
		}
	}

	return true, nil
}

// K8sActualNamespace returns K8sActualNamespaceResolver implementation.
func (r *Resolver) K8sActualNamespace() K8sActualNamespaceResolver {
	return &k8sActualNamespaceResolver{r}
}

// K8sActualSource returns K8sActualSourceResolver implementation.
func (r *Resolver) K8sActualSource() K8sActualSourceResolver { return &k8sActualSourceResolver{r} }

type k8sActualNamespaceResolver struct{ *Resolver }
type k8sActualSourceResolver struct{ *Resolver }
