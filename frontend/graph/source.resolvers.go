package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"

	"github.com/odigos-io/odigos/api/odigos/v1alpha1"
	"github.com/odigos-io/odigos/frontend/graph/loaders"
	"github.com/odigos-io/odigos/frontend/graph/model"
	sourceutils "github.com/odigos-io/odigos/k8sutils/pkg/source"
)

// MarkedForInstrumentation is the resolver for the markedForInstrumentation field.
func (r *k8sSourceResolver) MarkedForInstrumentation(ctx context.Context, obj *model.K8sSource) (*model.K8sSourceMakredForInstrumentation, error) {
	l := loaders.For(ctx)
	sources, err := l.GetSources(ctx, *obj.ID)
	if err != nil {
		return nil, err
	}

	enabled, reason, err := sourceutils.IsObjectInstrumentedBySource(ctx, sources, err)
	if err != nil {
		return nil, err
	}

	return &model.K8sSourceMakredForInstrumentation{
		MarkedForInstrumentation: enabled,
		DecisionEnum:             string(reason.Reason),
		Message:                  reason.Message,
	}, nil
}

// RuntimeInfo is the resolver for the runtimeInfo field.
func (r *k8sSourceResolver) RuntimeInfo(ctx context.Context, obj *model.K8sSource) (*model.K8sSourceRuntimeInfo, error) {
	l := loaders.For(ctx)
	ic, err := l.GetInstrumentationConfig(ctx, *obj.ID)
	if err != nil {
		return nil, err
	}

	var runtimeInfoReason *string
	var runtimeInfoMessage string = "runtime detection status not yet available"
	for _, c := range ic.Status.Conditions {
		if c.Type == v1alpha1.RuntimeDetectionStatusConditionType {
			runtimeInfoReason = &c.Reason
			runtimeInfoMessage = c.Message
		}
	}

	containers := make([]*model.K8sSourceRuntimeInfoContainer, len(ic.Status.RuntimeDetailsByContainer))
	for i, container := range ic.Status.RuntimeDetailsByContainer {
		var runtimeVersion *string
		if container.RuntimeVersion != "" {
			runtimeVersion = &container.RuntimeVersion
		}
		var otherAgentName *string
		if container.OtherAgent != nil {
			otherAgentName = &container.OtherAgent.Name
		}
		containers[i] = &model.K8sSourceRuntimeInfoContainer{
			ContainerName:           container.ContainerName,
			Language:                model.ProgrammingLanguage(container.Language),
			RuntimeVersion:          runtimeVersion,
			ProcessEnvVars:          envVarsToModel(container.EnvVars),
			ContainerRuntimeEnvVars: envVarsToModel(container.EnvFromContainerRuntime),
			CriErrorMessage:         container.CriErrorMessage,
			LibcType:                (*string)(container.LibCType),
			SecureExecutionMode:     container.SecureExecutionMode,
			OtherAgentName:          otherAgentName,
		}
	}

	runtimeInfo := &model.K8sSourceRuntimeInfo{
		Completed: len(ic.Status.RuntimeDetailsByContainer) > 0,
		CompletedStatus: &model.DesiredConditionStatus{
			Name:       v1alpha1.RuntimeDetectionStatusConditionType,
			Status:     runtimeDetectionStatusCondition(runtimeInfoReason),
			ReasonEnum: runtimeInfoReason,
			Message:    runtimeInfoMessage,
		},
		Containers: containers,
	}

	return runtimeInfo, nil
}

// AgentEnabled is the resolver for the agentEnabled field.
func (r *k8sSourceResolver) AgentEnabled(ctx context.Context, obj *model.K8sSource) (*model.K8sSourceAgentEnabled, error) {
	l := loaders.For(ctx)
	ic, err := l.GetInstrumentationConfig(ctx, *obj.ID)
	if err != nil {
		return nil, err
	}

	var agentEnabledStatus *model.DesiredConditionStatus
	for _, c := range ic.Status.Conditions {
		if c.Type == v1alpha1.AgentEnabledStatusConditionType {
			conditionStatus := agentEnabledStatusCondition(&c.Reason)
			agentEnabledStatus = &model.DesiredConditionStatus{
				Name:       c.Type,
				Status:     conditionStatus,
				ReasonEnum: &c.Reason,
				Message:    c.Message,
			}
			break
		}
	}

	containers := make([]*model.K8sSourceAgentEnabledContainer, len(ic.Spec.Containers))
	for i, container := range ic.Spec.Containers {
		reasonStr := string(container.AgentEnabledReason)
		var envInjectionMethodStr *string
		if container.EnvInjectionMethod != nil {
			asStr := string(*container.EnvInjectionMethod)
			envInjectionMethodStr = &asStr
		}

		var traces *model.K8sSourceAgentEnabledContainerTraces
		if container.Traces != nil {
			traces = &model.K8sSourceAgentEnabledContainerTraces{
				Enabled: true,
			}
		}
		var metrics *model.K8sSourceAgentEnabledContainerMetrics
		if container.Metrics != nil {
			metrics = &model.K8sSourceAgentEnabledContainerMetrics{
				Enabled: true,
			}
		}
		var logs *model.K8sSourceAgentEnabledContainerLogs
		if container.Logs != nil {
			logs = &model.K8sSourceAgentEnabledContainerLogs{
				Enabled: true,
			}
		}

		containers[i] = &model.K8sSourceAgentEnabledContainer{
			ContainerName: container.ContainerName,
			AgentEnabled:  true,
			AgentEnabledStatus: &model.DesiredConditionStatus{
				Name:       v1alpha1.AgentEnabledStatusConditionType,
				Status:     agentEnabledStatusCondition(&reasonStr),
				ReasonEnum: &reasonStr,
			},
			OtelDistroName:     emptyStrToNil(container.OtelDistroName),
			EnvInjectionMethod: envInjectionMethodStr,
			DistroParams:       distroParamsToModel(container.DistroParams),
			Traces:             traces,
			Metrics:            metrics,
			Logs:               logs,
		}
	}

	return &model.K8sSourceAgentEnabled{
		AgentEnabled:  ic.Spec.AgentInjectionEnabled,
		EnabledStatus: agentEnabledStatus,
		Containers:    containers,
	}, nil
}

// K8sSource returns K8sSourceResolver implementation.
func (r *Resolver) K8sSource() K8sSourceResolver { return &k8sSourceResolver{r} }

type k8sSourceResolver struct{ *Resolver }
