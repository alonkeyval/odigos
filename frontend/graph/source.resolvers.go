package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"

	"github.com/odigos-io/odigos/api/k8sconsts"
	"github.com/odigos-io/odigos/api/odigos/v1alpha1"
	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/kube"
	sourceutils "github.com/odigos-io/odigos/k8sutils/pkg/source"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func getWorkloadSources(ctx context.Context, namespace string, kind model.K8sResourceKind, name string) (*v1alpha1.WorkloadSources, error) {

	sources := v1alpha1.WorkloadSources{}

	workloadSources, err := kube.DefaultClient.OdigosClient.Sources(namespace).List(ctx, metav1.ListOptions{
		LabelSelector: fmt.Sprintf("%s=%s,%s=%s,%s=%s",
			k8sconsts.WorkloadNameLabel, name,
			k8sconsts.WorkloadNamespaceLabel, namespace,
			k8sconsts.WorkloadKindLabel, string(kind),
		),
	})
	if err != nil {
		return nil, err
	}
	if len(workloadSources.Items) > 1 {
		return nil, errors.New("found multiple sources for the same workload")
	}
	if len(workloadSources.Items) > 0 {
		sources.Workload = &workloadSources.Items[0]
	}

	nsSources, err := kube.DefaultClient.OdigosClient.Sources(namespace).List(ctx, metav1.ListOptions{
		LabelSelector: fmt.Sprintf("%s=%s,%s=%s,%s=%s",
			k8sconsts.WorkloadNameLabel, namespace,
			k8sconsts.WorkloadNamespaceLabel, namespace,
			k8sconsts.WorkloadKindLabel, k8sconsts.WorkloadKindNamespace,
		),
	})
	if err != nil {
		return nil, err
	}
	if len(nsSources.Items) > 1 {
		return nil, errors.New("found multiple sources for the same namespace")
	}
	if len(nsSources.Items) > 1 {
		sources.Namespace = &nsSources.Items[0]
	}

	return &sources, nil
}

// MarkedForInstrumentation is the resolver for the markedForInstrumentation field.
func (r *k8sSourceResolver) MarkedForInstrumentation(ctx context.Context, obj *model.K8sSource) (*model.K8sSourceMakredForInstrumentation, error) {

	sources, err := getWorkloadSources(ctx, obj.Namespace, obj.Kind, obj.Name)
	if err != nil {
		return nil, err
	}

	enabled, reason, err := sourceutils.IsObjectInstrumentedBySource(ctx, sources, err)
	if err != nil {
		return nil, err
	}

	return &model.K8sSourceMakredForInstrumentation{
		MarkedForInstrumentation: enabled,
		DecisionEnum:             string(reason.Reason),
		Message:                  reason.Message,
	}, nil
}

// K8sSource returns K8sSourceResolver implementation.
func (r *Resolver) K8sSource() K8sSourceResolver { return &k8sSourceResolver{r} }

type k8sSourceResolver struct{ *Resolver }
