enum ComputePlatformType {
  K8S
  VM
}

enum K8sResourceKind {
  Deployment
  DaemonSet
  StatefulSet
}

enum ConditionStatus {
  True
  False
  Unknown
}

enum ProgrammingLanguage {
  Unspecified
  Java
  Go
  JavaScript
  Python
  DotNet
}

enum SignalType {
  TRACES
  METRICS
  LOGS
}

enum SpanKind {
  Internal
  Server
  Client
  Producer
  Consumer
}

type SourceLanguage {
  containerName: String!
  language: String!
}

type InstrumentedApplicationDetails {
  languages: [SourceLanguage!]
  conditions: [Condition!]
}

type Condition {
  type: String!
  status: ConditionStatus!
  lastTransitionTime: String
  reason: String
  message: String
}

type K8sActualNamespace {
  name: String!
  autoInstrumented: Boolean

  k8sActualSources: [K8sActualSource]!
}

input K8sDesiredNamespaceInput {
  autoInstrument: Boolean
}
input K8sNamespaceId {
  name: String!
}

type K8sActualSource {
  namespace: String!
  kind: K8sResourceKind!
  name: String!
  serviceName: String
  autoInstrumented: Boolean
  creationTimestamp: String
  numberOfInstances: Int
  # Odigos records an array of runtime infos.
  # currently we only keep the first one assuming it is the user's app.
  hasInstrumentedApplication: Boolean!
  instrumentedApplicationDetails: InstrumentedApplicationDetails
}
type K8sActualSourceRuntimeInfo {
  mainContainer: K8sActualSourceRuntimeInfoContainer
}
type K8sActualSourceRuntimeInfoContainer {
  containerName: String!
  language: ProgrammingLanguage!
}

input K8sDesiredSourceInput {
  serviceName: String
  autoInstrument: Boolean
}
input K8sSourceId {
  namespace: String!
  kind: K8sResourceKind!
  name: String!
}

type DestinationSpecField {
  name: String!
  value: String!
}
type ActualDestination {
  id: ID!
  name: String!
  type: DestinationType!
  exportedSignals: [SignalType!]!
  fields: [DestinationSpecField!]!
}
type DesiredDestination {
  id: ID!
  name: String!
  type: DestinationType!
  exportSignals: [SignalType!]!
  fields: [DestinationSpecField!]!

  # compute platforms that include this destination
  computePlatforms: [ComputePlatform!]!
}
input DesiredDestinationFieldInput {
  name: String!
  value: String!
}
input DesiredDestinationInput {
  name: String!
  exportSignals: [SignalType!]!
  fields: [DesiredDestinationFieldInput!]!
}

type DestinationTypeField {
  name: String!
  displayName: String!
  videoURL: String
  thumbnailURL: String
  componentType: String!
  # componentProps is JSON stringified data as text
  componentProps: String!
  secret: Boolean!
  initialValue: String
}
type DestinationType {
  # category is currently "managed" or "self hosted"
  category: String!
  # the name of the destination type (prometheus, jaeger, etc)
  name: String!
  # same destination type "name", but used for display (for example can contain spaces)
  displayName: String!

  # name of an image file to be used for this destination type
  # the image themselves are stored [here](https://s3.console.aws.amazon.com/s3/buckets/odigos-destinations)
  image: String

  # the signals that this destination type supports
  supportedSignals: [SignalType!]!

  fields: [DestinationTypeField!]!
}
type DestinationTypeCategory {
  # the name of the category
  name: String!
  destinationTypes: [DestinationType]!
}

type ComputePlatform {
  id: ID!
  name: String
  computePlatformType: ComputePlatformType!

  k8sActualNamespace(name: String!): K8sActualNamespace
  k8sActualNamespaces: [K8sActualNamespace]!
  k8sActualSource(
    name: String
    namespace: String
    kind: String
  ): K8sActualSource
  k8sActualSources: [K8sActualSource]!

  # destinations that are applied to this compute platform
  actualDestinations: [ActualDestination]!
  actualActions: [ActualAction]!
}

# Define the input type for Workload
input WorkloadInput {
  kind: K8sResourceKind!
  name: String!
  namespace: String!
}

input DesiredActionInput {
  kind: String!
  name: String
  notes: String
  disable: Boolean!
  signals: [SignalType!]!
  details: String!
}

type ActualAction {
  id: ID!
  kind: String!
  name: String
  notes: String
  disable: Boolean!
  signals: [SignalType!]!
  details: String!
}

type Query {
  computePlatform(cpId: ID!): ComputePlatform
  destinationTypeCategories: [DestinationTypeCategory]
  desiredDestinations: [DesiredDestination]
}

type Mutation {
  # desired namespace mutations
  applyDesiredNamespace(
    cpId: ID!
    nsId: K8sNamespaceId!
    ns: K8sDesiredNamespaceInput!
  ): Boolean!
  deleteDesiredNamespace(cpId: ID!, nsId: K8sNamespaceId!): Boolean!

  #k8s desired source mutations
  applyDesiredSource(
    cpId: ID!
    sourceId: K8sSourceId!
    source: K8sDesiredSourceInput!
  ): Boolean!
  deleteDesiredSource(cpId: ID!, sourceId: K8sSourceId!): Boolean!

  # desired destination mutations
  createDesiredDestination(
    destinationType: String!
    destination: DesiredDestinationInput!
  ): DesiredDestination!
  updateDesiredDestination(
    destinationId: ID!
    destination: DesiredDestinationInput!
  ): DesiredDestination!
  deleteDesiredDestination(destinationId: ID!): Boolean!
  applyDesiredDestinationToComputePlatform(
    cpId: ID!
    destinationId: ID!
  ): Boolean!
  removeDesiredDestinationFromComputePlatform(
    cpId: ID!
    destinationId: ID!
  ): Boolean!

  # actions mutations
  createDesiredAction(cpId: ID!, action: DesiredActionInput!): Boolean!
  updateDesiredAction(
    cpId: ID!
    actionId: String!
    action: DesiredActionInput!
  ): Boolean!
  deleteActualAction(cpId: ID!, actionId: String!, kind: String!): Boolean!
}
